<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prosody Player — Playlist + Waveform + Adaptive Pulse + Stress Markers</title>
  <style>
    :root{--bg:#0b0c0f;--ink:#e7e9ee;--muted:#9aa3b2;--panel:#14161a;--accent:#6ae2ff;--accent2:#2b97ad;--mark:#ffd166}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    .wrap{max-width:1100px;margin:0 auto;padding:24px;display:grid;gap:18px}
    .card{position:relative;background:var(--panel);border:1px solid rgba(255,255,255,.08);border-radius:16px;box-shadow:0 12px 28px rgba(0,0,0,.25);overflow:hidden}
    .controls{display:flex;align-items:center;gap:10px;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.06)}
    .btn{background:#0f1218;border:1px solid rgba(255,255,255,.12);color:var(--ink);border-radius:999px;padding:8px 14px;cursor:pointer}
    .pill{margin-left:auto;display:inline-block;padding:2px 8px;border-radius:999px;background:#0f1218;border:1px solid rgba(255,255,255,.12);font-size:12px;color:var(--muted)}
    #overview{height:72px}

    /* Detail wrapper + overlay canvas for markers */
    .detailWrap{position:relative;height:210px;border-top:1px solid rgba(255,255,255,.06)}
    #detail{position:absolute;inset:0}
    #marks{position:absolute;inset:0;pointer-events:none}

    @media (min-width: 980px){ .grid-2{display:grid;grid-template-columns: 320px 1fr;gap:18px} }

    /* Playlist */
    .plist{padding:10px}
    .plistHead{display:flex;align-items:center;gap:10px;justify-content:space-between;margin:6px 8px 8px}
    .plist h3{margin:0;font-size:14px;color:var(--muted);font-weight:600;letter-spacing:.02em}
    .seg{display:inline-flex;background:#0f1218;border:1px solid rgba(255,255,255,.12);border-radius:999px;overflow:hidden}
    .seg button{border:0;background:transparent;color:var(--muted);padding:6px 10px;font-size:12px;cursor:pointer}
    .seg button.active{background:rgba(106,226,255,.15);color:var(--ink)}
    .tracks{display:flex;flex-direction:column;gap:8px;padding:0 8px 12px}
    .track{display:flex;align-items:center;gap:10px;padding:10px 12px;border:1px solid rgba(255,255,255,.06);border-radius:12px;background:#0f1218;cursor:pointer}
    .track:hover{border-color:rgba(255,255,255,.14)}
    .dot{width:8px;height:8px;border-radius:999px;background:#3a4350}
    .track.active .dot{background:var(--accent)}
    .tmeta{display:flex;flex-direction:column}
    .ttitle{font-size:14px}
    .tsub{font-size:12px;color:var(--muted)}
    .addhint{margin:6px 8px 12px;font-size:12px;color:var(--muted)}

    /* Pulse strip (separate) */
    .pulse-panel{height:230px; display:grid; place-items:center}
    .pulse{
      width:120px;height:120px;border-radius:999px;
      background:radial-gradient(circle at 50% 45%, rgba(255,255,255,.11), rgba(255,255,255,.02) 60%, rgba(255,255,255,0) 70%);
      outline:2px solid rgba(106,226,255,.22);
      box-shadow:0 0 0 0 rgba(106,226,255,.18), 0 0 26px rgba(106,226,255,.08) inset;
      transform:scale(1);
      transition:transform 60ms linear, box-shadow 60ms linear, outline-color 60ms linear;
    }
  </style>
</head>
<body>
  <div class="wrap">

    <div class="grid-2">
      <!-- Playlist panel -->
      <div class="card plist">
        <div class="plistHead">
          <h3>Playlist</h3>
          <div class="seg" id="sensSeg">
            <button data-mode="low">Low</button>
            <button data-mode="med" class="active">Mid</button>
            <button data-mode="hi">High</button>
          </div>
        </div>
        <div id="tracks" class="tracks"></div>
        <div class="addhint">Add a <code>tracks.json</code> alongside this file to populate the list.</div>
      </div>

      <!-- Waveform card -->
      <div class="card" id="wf">
        <div class="controls">
          <button class="btn" id="play">▶️</button>
          <button class="btn" id="pause">⏸️</button>
          <button class="btn" id="zoomOut">➖</button>
          <button class="btn" id="zoomIn">➕</button>
          <span class="pill" id="time">-- / --</span>
        </div>
        <div id="overview"></div>
        <div class="detailWrap">
          <div id="detail"></div>
          <canvas id="marks"></canvas>
        </div>
      </div>
    </div>

    <!-- Pulse card (separate) -->
    <div class="card pulse-panel">
      <div id="pulse" class="pulse"></div>
    </div>

  </div>

  <script src="./wavesurfer.min.js"></script>

  <!-- Waveform + Playlist + Sensitivity UI -->
  <script>
  (function(){
    const qp=(k,d)=>new URLSearchParams(location.search).get(k)||d;
    const defaultSrc = qp('src', qp('voice','voice.mp3')); // ?src=... or ?voice=...
    const rate = +(qp('rate', 0.8)); // playback rate
    const sensQP = (qp('sens','med')||'').toLowerCase();

    // Global settings for pulse & markers
    window.ProsodySettings = {
      sensMode: ['low','med','hi'].includes(sensQP) ? sensQP : 'med',
      sensExtra: (!isNaN(parseFloat(sensQP)) && isFinite(sensQP)) ? parseFloat(sensQP) : 0
    };

    const tracksEl = document.getElementById('tracks');

    // Create WaveSurfer instances
    const wsOverview=WaveSurfer.create({
      container:'#overview',height:72,waveColor:'#24313b',progressColor:'#435564',
      cursorColor:'transparent',barWidth:1,barGap:0,normalize:true,interact:true,dragToSeek:true,responsive:true
    });

    let pxPerSec=220; window.pxPerSec = pxPerSec;
    const wsDetail=WaveSurfer.create({
      container:'#detail',height:210,waveColor:'#2b97ad',progressColor:'#6ae2ff',cursorColor:'#6ae2ff',
      barWidth:2,barGap:1,barRadius:1,minPxPerSec:pxPerSec,autoCenter:true,hideScrollbar:false,dragToSeek:true,
      normalize:true,responsive:true
    });

    // Expose globally
    window.wsDetail = wsDetail;

    // Playback rate + preserve pitch
    wsDetail.setPlaybackRate(rate);
    const media = wsDetail.getMediaElement && wsDetail.getMediaElement();
    if (media) {
      media.preservesPitch = true;
      media.mozPreservesPitch = true;
      media.webkitPreservesPitch = true;
    }

    // Controls
    const timePill=document.getElementById('time');
    document.getElementById('zoomIn').onclick = ()=>{ pxPerSec=Math.min(1400,pxPerSec*1.18); window.pxPerSec=pxPerSec; wsDetail.setOptions({minPxPerSec:pxPerSec}); document.dispatchEvent(new Event('zoomchange')); };
    document.getElementById('zoomOut').onclick= ()=>{ pxPerSec=Math.max(40,  pxPerSec/1.18); window.pxPerSec=pxPerSec; wsDetail.setOptions({minPxPerSec:pxPerSec}); document.dispatchEvent(new Event('zoomchange')); };
    document.getElementById('play').onclick   = ()=> wsDetail.play();
    document.getElementById('pause').onclick  = ()=> wsDetail.pause();

    function syncOverview(){ const t=wsDetail.getCurrentTime()||0, d=wsDetail.getDuration()||1; if(wsOverview.setTime) wsOverview.setTime(t); else wsOverview.seekTo(t/d); }
    wsDetail.on('timeupdate',()=>{ syncOverview(); const t=wsDetail.getCurrentTime()||0, d=wsDetail.getDuration()||0; timePill.textContent=`${t.toFixed(2)} / ${d.toFixed(2)} s`; document.dispatchEvent(new Event('frametick')); });
    wsDetail.on('seek',()=>{ syncOverview(); document.dispatchEvent(new Event('frametick')); });
    wsDetail.on('redraw',()=> document.dispatchEvent(new Event('frametick')));
    wsOverview.on('seek',rel=> wsDetail.seekTo(rel));

    // ---- Playlist logic ----
    let playlist = [];

    async function fetchTracksJSON(){
      try{
        const r = await fetch('tracks.json', {cache:'no-store'});
        if(!r.ok) return null;
        const j = await r.json();
        if(Array.isArray(j)) return j;
        if(j && Array.isArray(j.tracks)) return j.tracks;
        return null;
      }catch{ return null; }
    }

    function renderPlaylist(list, selectedFile){
      tracksEl.innerHTML = '';
      list.forEach((t)=>{
        const btn = document.createElement('button');
        btn.className = 'track' + (t.file===selectedFile ? ' active' : '');
        btn.innerHTML = `
          <span class="dot"></span>
          <span class="tmeta">
            <span class="ttitle">${t.title || t.file}</span>
            <span class="tsub">${t.file}</span>
          </span>`;
        btn.onclick = ()=> loadTrack(t.file, true);
        tracksEl.appendChild(btn);
      });
    }

    function setActive(file){
      Array.from(tracksEl.children).forEach(el=>{
        const is = el.querySelector('.tsub')?.textContent.trim()===file;
        el.classList.toggle('active', !!is);
      });
    }

    function loadIntoWavesurfer(file){
      wsOverview.load(file);
      wsDetail.load(file);
      timePill.textContent='-- / --';
    }

    function notifyTrackChange(file){
      document.dispatchEvent(new CustomEvent('trackchange', { detail:{ src:file } }));
      const url = new URL(location.href);
      url.searchParams.set('src', file);
      history.replaceState(null, '', url.toString());
    }

    function loadTrack(file, userInitiated=false){
      wsDetail.pause();
      loadIntoWavesurfer(file);
      setActive(file);
      notifyTrackChange(file);
      if(userInitiated){
        wsDetail.once('ready', ()=> wsDetail.play());
      }
    }

    (async ()=>{
      const fromUrl = defaultSrc;
      const fromJson = await fetchTracksJSON();
      if(fromJson && fromJson.length){
        playlist = fromJson;
        const chosen = (playlist.find(t=>t.file===fromUrl) || playlist[0]).file;
        renderPlaylist(playlist, chosen);
        loadTrack(chosen, false);
      }else{
        playlist = [{ file: fromUrl, title: 'Track' }];
        renderPlaylist(playlist, fromUrl);
        loadTrack(fromUrl, false);
      }
    })();

    // ---- Sensitivity toggle UI ----
    const seg = document.getElementById('sensSeg');
    function setSegActive(mode){
      Array.from(seg.querySelectorAll('button')).forEach(b=> b.classList.toggle('active', b.dataset.mode===mode));
    }
    setSegActive(window.ProsodySettings.sensMode);
    seg.addEventListener('click', (e)=>{
      const btn = e.target.closest('button[data-mode]');
      if(!btn) return;
      const mode = btn.dataset.mode;
      window.ProsodySettings.sensMode = mode;
      window.ProsodySettings.sensExtra = 0; // clear numeric override
      setSegActive(mode);
      document.dispatchEvent(new CustomEvent('sensitivitychange', { detail:{ mode } }));
    });
  })();
  </script>

  <!-- Adaptive Pulse (per-track normalization + auto threshold + sensitivity toggle) + Stress Index -->
  <script>
  (function(){
    const pulseEl = document.getElementById('pulse');

    // Analysis / dynamics
    const FRAME_MS = 30, HOP_MS = 8, ATK_MS = 18, REL_MS = 160;
    const MIN_S = 0.98, MAX_S = 3.10, GAMMA = 0.9;

    let env=null;
    let calib = { p10:0, p96:1, thrNorm:0.6, baseBias:-0.05 };
    let armed=false;
    let syl=null; // syllable detection results

    function sensExtraFromMode(){
      const ps = (window.ProsodySettings||{sensMode:'med', sensExtra:0});
      const modeOffset = ps.sensMode==='hi' ? -0.03 : (ps.sensMode==='low' ? +0.03 : 0);
      return modeOffset + (ps.sensExtra||0);
    }

    const ws = window.wsDetail;
    if (ws) ws.on('ready', arm);
    document.addEventListener('trackchange', ()=>{ reset(); if (ws) ws.once('ready', arm); });
    document.addEventListener('sensitivitychange', ()=>{/* loop reads live */});

    function reset(){ env=null; armed=false; calib = { p10:0, p96:1, thrNorm:0.6, baseBias:-0.05 }; syl=null; window.getSyllables = ()=>null; }

    function arm(){
      if (armed) return;
      armed = true;
      precomputeEnvelope().then(()=>{ calibrate(); syl = computeSyllables(env); window.getSyllables=()=>syl; document.dispatchEvent(new Event('syllablesready')); startPulseLoop(); })
        .catch(e=>{ console.warn('Envelope fail:', e); armed=false; });
    }

    async function precomputeEnvelope(){
      let buf = (ws && ws.getDecodedData && ws.getDecodedData());
      if (!buf) {
        const url = new URL(location.href);
        const src = url.searchParams.get('src') || url.searchParams.get('voice') || 'voice.mp3';
        const ac = new (window.AudioContext||window.webkitAudioContext)();
        if (ac.state === 'suspended') { try { await ac.resume(); } catch{} }
        const ab = await fetch(src,{cache:'no-store'}).then(r=>r.arrayBuffer());
        buf = await ac.decodeAudioData(ab);
        ac.close();
      }
      const sr = buf.sampleRate, ch = buf.getChannelData(0);
      const frame = Math.max(64, Math.round(FRAME_MS*sr/1000));
      const hop   = Math.max(16, Math.round(HOP_MS  *sr/1000));
      const out = []; let maxR = 1e-12;
      for (let i=0; i+frame<=ch.length; i+=hop){
        let e=0; for (let j=0;j<frame;j++){ const v=ch[i+j]; e+=v*v; }
        const r = Math.sqrt(e/frame); if (r>maxR) maxR=r; out.push({t:i/sr, r});
      }
      for (const p of out) p.r /= maxR; // normalize 0..1 per file
      env = out;
    }

    function calibrate(){
      const vals = env.map(p=>p.r).slice().sort((a,b)=>a-b);
      const Q = (pct)=> vals[Math.min(vals.length-1, Math.max(0, Math.round((pct/100)*vals.length)))];

      const p10 = Q(10), p50 = Q(50), p96 = Q(96), p98 = Q(98);
      const crest = p98 / Math.max(1e-6, p50);

      let thrPct, baseBias;
      if (crest < 2.0){      thrPct = 68; baseBias = -0.08; }
      else if (crest < 3.0){ thrPct = 72; baseBias = -0.06; }
      else {                  thrPct = 74; baseBias = -0.05; }

      const thrVal = Q(thrPct);
      const range = Math.max(1e-9, (p96 - p10));

      calib.p10 = p10;
      calib.p96 = p96;
      calib.thrNorm = Math.max(0, Math.min(0.98, (thrVal - p10)/range));
      calib.baseBias = baseBias;
    }

    // ---------- Stress Index (duration + prominence) ----------
    function computeSyllables(env){
      if(!env || env.length < 5) return null;
      const times = env.map(p=>p.t), vals = env.map(p=>p.r);
      const hopSec = Math.max( (env[1]?.t || 0) - (env[0]?.t || 0), 0.005 );

      // local median baseline (250 ms)
      const winSec = 0.25, halfWin = Math.max(1, Math.round(winSec / hopSec / 2));
      const baseline = [];
      for (let i=0;i<vals.length;i++){
        const a = Math.max(0, i - halfWin), b = Math.min(vals.length-1, i + halfWin);
        const seg = vals.slice(a, b+1).slice().sort((x,y)=>x-y);
        baseline.push(seg[Math.floor(seg.length/2)] || 1e-6);
      }

      // peaks with debounce (>=110 ms)
      const minGap = Math.round(0.11 / hopSec);
      const peaks = [];
      for (let i=1;i<vals.length-1;i++){
        if (vals[i] > vals[i-1] && vals[i] >= vals[i+1]) {
          const last = peaks.length ? peaks[peaks.length-1].idx : -1;
          if (last < 0 || (i - last) >= minGap) peaks.push({ idx:i });
        }
      }

      const out = [];
      for (const pk of peaks){
        const i = pk.idx;
        const v = Math.max(vals[i], 1e-9), base = Math.max(baseline[i], 1e-9);
        const promDb = 20 * Math.log10(v / base);
        const thr = v / Math.SQRT2; // -6 dB
        let L = i, R = i;
        while (L > 0 && vals[L] >= thr) L--;
        while (R < vals.length-1 && vals[R] >= thr) R++;
        const durMs = (times[R] - times[L]) * 1000;
        out.push({ t: times[i], promDb, durMs });
      }
      if (!out.length) return null;

      // normalize via p10..p90
      const P = (arr, pct)=>{
        const s = arr.slice().sort((a,b)=>a-b);
        const k = Math.min(s.length-1, Math.max(0, Math.round(pct/100 * s.length)));
        return s[k];
      };
      const promArr = out.map(o=>o.promDb), durArr = out.map(o=>o.durMs);
      const p10P=P(promArr,10), p90P=Math.max(P(promArr,90), p10P+1e-6);
      const p10D=P(durArr,10),  p90D=Math.max(P(durArr,90),  p10D+1e-6);
      const norm = (v,a,b)=> Math.max(0, Math.min(1, (v-a)/(b-a)));

      for (const o of out){
        const nP = norm(o.promDb, p10P, p90P);
        const nD = norm(o.durMs,  p10D, p90D);
        o.nProm = nP; o.nDur = nD; o.NSI = 0.6*nD + 0.4*nP;
      }

      const NSIs = out.map(o=>o.NSI);
      const mean = NSIs.reduce((a,b)=>a+b,0)/NSIs.length;
      const sd   = Math.sqrt(NSIs.reduce((a,b)=>a+(b-mean)*(b-mean),0)/NSIs.length) || 1e-6;
      const thrNSI = Math.min(0.95, Math.max(0.45, mean + 0.3*sd));
      const stressed = out.filter(o=> o.NSI >= thrNSI);

      return { peaks: out, stressed, thrNSI };
    }

    function interpEnv(t){
      if (!env || !env.length) return 0;
      let lo=0, hi=env.length-1;
      while (lo<hi){ const mid=(lo+hi)>>1; if (env[mid].t < t) lo=mid+1; else hi=mid; }
      return env[Math.max(0, Math.min(env.length-1, lo))].r;
    }

    // Pulse loop
    let raf=0, smoothed=0, lastS=1.0;
    function startPulseLoop(){
      cancelAnimationFrame(raf);
      const fpsCoef = (ms)=> Math.exp(-1 / ((ms/1000)*60));
      const atk = fpsCoef(ATK_MS), rel = fpsCoef(REL_MS);
      const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
      const loop=()=>{
        const t = (window.wsDetail && window.wsDetail.getCurrentTime && window.wsDetail.getCurrentTime()) || 0;

        const r  = interpEnv(t);
        const rn = clamp((r - calib.p10) / Math.max(1e-9, (calib.p96 - calib.p10)), 0, 1);

        const thr = clamp(calib.thrNorm + calib.baseBias + sensExtraFromMode(), 0, 0.98);
        let x = clamp((rn - thr) / Math.max(1e-9, (1 - thr)), 0, 1);
        x = Math.pow(x, GAMMA);

        const coeff = (x>smoothed)? (1- atk*atk) : (1- rel*rel);
        smoothed = smoothed + coeff * (x - smoothed);

        let s = MIN_S + (MAX_S - MIN_S) * smoothed;
        s = lastS + clamp(s - lastS, -0.10, 0.10);
        lastS = s;

        pulseEl.style.transform = `scale(${s.toFixed(3)})`;
        const glow = 0.16 + 0.26*smoothed;
        pulseEl.style.boxShadow =
          `0 0 0 ${Math.round(10+36*smoothed)}px rgba(106,226,255,${glow}), `+
          `0 0 ${Math.round(22+48*smoothed)}px rgba(106,226,255,${0.10+0.22*smoothed}) inset`;

        raf = requestAnimationFrame(loop);
      };
      raf = requestAnimationFrame(loop);
    }
  })();
  </script>

  <!-- Marker overlay (draw stressed syllables over the detail waveform) -->
  <script>
  (function(){
    const canvas = document.getElementById('marks');
    const ctx = canvas.getContext('2d');

    function resize(){
      const dpr = Math.max(1, window.devicePixelRatio||1);
      const rect = canvas.getBoundingClientRect();
      canvas.width  = Math.max(1, Math.floor(rect.width  * dpr));
      canvas.height = Math.max(1, Math.floor(rect.height * dpr));
      canvas.style.width  = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    resize(); window.addEventListener('resize', resize);

    function draw(){
      const ws = window.wsDetail; if(!ws) return;
      const syl = (window.getSyllables && window.getSyllables()) || null;
      const pxPerSec = window.pxPerSec || 220;
      const W = canvas.clientWidth || canvas.width, H = canvas.clientHeight || canvas.height;
      ctx.clearRect(0,0,W,H);

      if(!syl || !syl.stressed || !syl.stressed.length) return;

      const cur = ws.getCurrentTime()||0, dur = ws.getDuration()||1;
      const secondsVisible = (W / pxPerSec);
      const start = Math.max(0, Math.min(cur - secondsVisible/2, Math.max(0, dur - secondsVisible)));
      const end = start + secondsVisible;

      // Subtle baseline grid
      ctx.strokeStyle = 'rgba(255,255,255,.06)';
      ctx.lineWidth = 1;
      for(let i=1;i<=3;i++){ const y=(H*i/4)+0.5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

      // Draw stressed markers
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--mark').trim() || '#ffd166';
      ctx.lineWidth = 2;
      syl.stressed.forEach(s=>{
        if(s.t >= start && s.t <= end){
          const x = Math.round((s.t - start) * pxPerSec) + 0.5;
          ctx.beginPath();
          ctx.moveTo(x, 6);
          ctx.lineTo(x, H-6);
          ctx.stroke();

          // small cap at top for visibility
          ctx.beginPath(); ctx.moveTo(x-4,6); ctx.lineTo(x+4,6); ctx.stroke();
        }
      });
    }

    // Redraw on timeline updates / zoom / new syllables
    document.addEventListener('frametick', draw);
    document.addEventListener('zoomchange', draw);
    document.addEventListener('syllablesready', ()=>{ resize(); draw(); });

    // Also on resize and after Wavesurfer redraws (already forwarded as frametick)
    window.addEventListener('resize', draw);
  })();
  </script>
</body>
</html>
