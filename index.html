<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prosody Player</title>
  <style>
    :root{--bg:#0b0c0f;--ink:#e7e9ee;--muted:#9aa3b2;--panel:#14161a;--accent:#6ae2ff;--intensity:#00e08a;--cursor:#ff6b6b}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    .wrap{max-width:1100px;margin:0 auto;padding:24px}
    .card{position:relative;background:var(--panel);border:1px solid rgba(255,255,255,.08);border-radius:16px;box-shadow:0 12px 28px rgba(0,0,0,.25);overflow:hidden}
    .controls{display:flex;align-items:center;gap:10px;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.06)}
    .btn{background:#0f1218;border:1px solid rgba(255,255,255,.12);color:var(--ink);border-radius:999px;padding:8px 14px;cursor:pointer}
    .pill{margin-left:auto;display:inline-block;padding:2px 8px;border-radius:999px;background:#0f1218;border:1px solid rgba(255,255,255,.12);font-size:12px;color:var(--muted)}
    #voiceWave{height:180px}
    #overlay{position:absolute;left:0;top:49px;right:0;height:180px;pointer-events:none}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="controls">
        <button class="btn" id="play">▶️</button>
        <button class="btn" id="pause">⏸️</button>
        <span class="pill" id="time">-- / --</span>
      </div>
      <div id="voiceWave"></div>
      <canvas id="overlay"></canvas>
      <audio id="voice" preload="auto" hidden></audio>
    </div>
  </div>  <!-- Local WaveSurfer build (placed in repo root) -->  <script src="./wavesurfer.min.js"></script>  <script>
  (function(){
    const qp = (k, d) => (new URLSearchParams(location.search).get(k) || d);
    const src = qp('voice','voice.mp3');

    // ---------- WaveSurfer (waveform + playback) ----------
    const ws = WaveSurfer.create({
      container: '#voiceWave',
      height: 180,
      waveColor: '#2b97ad',
      progressColor: '#6ae2ff',
      cursorColor: 'transparent',
      normalize: true,
      responsive: true,
      dragToSeek: true,
    });
    ws.load(src);

    const timePill = document.getElementById('time');
    document.getElementById('play').onclick = ()=> ws.play();
    document.getElementById('pause').onclick = ()=> ws.pause();

    ws.on('decode', dur => timePill.textContent = `0.00 / ${dur.toFixed(2)} s`);
    ws.on('timeupdate', t => timePill.textContent = `${t.toFixed(2)} / ${(ws.getDuration()||0).toFixed(2)} s`);

    // ---------- Overlay (pitch + intensity + cursor) ----------
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    function resizeOverlay(){
      const dpr = Math.max(1, devicePixelRatio||1);
      const {width, height} = ws.getWrapper().getBoundingClientRect();
      overlay.width = Math.max(1, Math.floor(width*dpr));
      overlay.height = Math.max(1, Math.floor(height*dpr));
      overlay.style.width = width+"px"; overlay.style.height = height+"px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
      drawOverlay();
    }

    // Compute pitch (autocorrelation) + intensity (RMS) from decoded PCM
    let feats = null; // [{t, f0 (Hz or 0), rms}]
    async function computeFeatures(){
      try{
        // We already loaded audio via WS, but we re-fetch for analysis to access PCM easily
        const ac = new (window.AudioContext||window.webkitAudioContext)();
        const ab = await fetch(src, {cache:'no-store'}).then(r=>r.arrayBuffer());
        const buf = await ac.decodeAudioData(ab);
        const s = buf.getChannelData(0);
        const sr = buf.sampleRate;
        const frame = 2048, hop = 256; // ~46 ms frame, ~6 ms hop at 44.1kHz
        const minF = 60, maxF = 400;
        const minLag = Math.floor(sr/maxF), maxLag = Math.floor(sr/minF);
        const out = [];
        const hann = new Float32Array(frame); for(let i=0;i<frame;i++){ hann[i] = 0.5*(1 - Math.cos(2*Math.PI*i/(frame-1))); }
        for(let i=0;i+frame < s.length; i+=hop){
          // window
          let rms=0; for(let j=0;j<frame;j++){ const v = s[i+j]*hann[j]; rms += v*v; }
          rms = Math.sqrt(rms/frame);
          // skip voiceless
          let bestLag = 0, best = 0;
          for(let lag=minLag; lag<=maxLag; lag++){
            let corr=0, norm1=0, norm2=0;
            for(let j=0;j<frame-lag;j++){
              const a = s[i+j]*hann[j];
              const b = s[i+j+lag]*hann[j+lag];
              corr += a*b; norm1 += a*a; norm2 += b*b;
            }
            const denom = Math.sqrt(norm1*norm2)+1e-12;
            const c = corr/denom;
            if(c>best){best=c; bestLag=lag;}
          }
          const thresh = 0.6; // correlation threshold for voicing
          const f0 = (best>thresh) ? (sr/bestLag) : 0;
          out.push({ t: i/sr, f0, rms });
        }
        ac.close();
        // light smoothing
        for(let k=1;k<out.length-1;k++){
          out[k].f0 = out[k-1].f0*0.25 + out[k].f0*0.5 + out[k+1].f0*0.25;
          out[k].rms = out[k-1].rms*0.25 + out[k].rms*0.5 + out[k+1].rms*0.25;
        }
        feats = out;
        resizeOverlay();
      }catch(e){ console.warn('Analysis failed', e); }
    }

    function drawOverlay(){
      const W = overlay.width, H = overlay.height; if(!W||!H) return;
      ctx.clearRect(0,0,W,H);
      // intensity area (bottom band)
      if(feats && feats.length){
        const dur = ws.getDuration()|| (feats.at(-1)?.t||1);
        ctx.fillStyle = 'rgba(0,224,138,0.18)';
        ctx.beginPath(); ctx.moveTo(0,H);
        feats.forEach(p=>{
          const x = (p.t/dur)*W; const y = H - Math.min(H, (p.rms*1.8)*H);
          ctx.lineTo(x,y);
        });
        ctx.lineTo(W,H); ctx.closePath(); ctx.fill();
      }
      // pitch curve
      if(feats && feats.length){
        const fmin=60, fmax=400; const dur = ws.getDuration()|| (feats.at(-1)?.t||1);
        ctx.strokeStyle = '#6ae2ff'; ctx.lineWidth = 2; ctx.beginPath(); let started=false;
        feats.forEach(p=>{
          if(p.f0>0){
            const x = (p.t/dur)*W;
            const y = H - ((p.f0 - fmin)/(fmax - fmin))*H;
            if(!started){ctx.moveTo(x,y); started=true;} else ctx.lineTo(x,y);
          } else {
            started=false;
          }
        });
        ctx.stroke();
      }
      // playhead
      const t = ws.getCurrentTime();
      const dur = ws.getDuration()||1; const x = (t/dur)*W;
      ctx.strokeStyle = 'var(--cursor)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,H); ctx.stroke();
    }

    // redraw on resize and while playing
    ws.on('ready', () => { resizeOverlay(); computeFeatures(); });
    ws.on('redraw', resizeOverlay);
    ws.on('timeupdate', drawOverlay);
    window.addEventListener('resize', resizeOverlay);
  })();
  </script></body>
</html>